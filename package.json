{
  "name": "darkmaker-backend",
  "version": "1.0.0",
  "description": "Backend para o AI Media Suite",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": ["video", "ffmpeg", "timeline", "AI"],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "cors": "^2.8.5",
    "express": "^4.19.2",
    "multer": "^1.4.5-lts.1",
    "archiver": "^7.0.1",
    "@google-cloud/speech": "^6.5.0",
    "fluent-ffmpeg": "^2.1.3",
    "node-fetch": "^2.7.0"
  }
const express = require('express');
const multer = require('multer');
const ffmpeg = require('fluent-ffmpeg');
const path = require('path');
const fs = require('fs');
const fetch = require('node-fetch');

const app = express();
app.use(express.json());

const UPLOAD_DIR = 'uploads';
if (!fs.existsSync(UPLOAD_DIR)) fs.mkdirSync(UPLOAD_DIR);

const upload = multer({ dest: UPLOAD_DIR });

// Função para baixar vídeo de URL
async function downloadVideo(url, destPath) {
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Falha ao baixar vídeo: ${url}`);
  const fileStream = fs.createWriteStream(destPath);
  await new Promise((resolve, reject) => {
    res.body.pipe(fileStream);
    res.body.on("error", reject);
    fileStream.on("finish", resolve);
  });
  return destPath;
}

// Endpoint POST /render-timeline com download direto
app.post('/render-timeline', upload.array('videos'), async (req, res) => {
  try {
    console.log('Payload JSON:', req.body);
    console.log('Arquivos enviados:', req.files);

    let videoPaths = [];

    // 1️⃣ Uploads físicos
    if (req.files && req.files.length > 0) {
      videoPaths = req.files.map(f => f.path);
    }

    // 2️⃣ Vídeos via JSON (URLs ou caminhos locais)
    if (req.body.videos && req.body.videos.length > 0) {
      for (const video of req.body.videos) {
        if (video.startsWith('http')) {
          const fileName = `uploads/${Date.now()}-${path.basename(video)}`;
          await downloadVideo(video, fileName);
          videoPaths.push(fileName);
        } else {
          if (!fs.existsSync(video)) {
            return res.status(400).json({ error: `Vídeo não encontrado: ${video}` });
          }
          videoPaths.push(video);
        }
      }
    }

    if (videoPaths.length === 0) {
      return res.status(400).json({ error: 'Nenhum vídeo fornecido' });
    }

    // 3️⃣ Monta comando FFmpeg
    let command = ffmpeg();
    videoPaths.forEach(video => command = command.input(video));

    const videoInputs = videoPaths.map((_, i) => `[${i}:v:0]`).join('');
    const audioInputs = videoPaths.map((_, i) => `[${i}:a:0]`).join('');
    const filterComplex = [
      `${videoInputs}concat=n=${videoPaths.length}:v=1:a=0[v]`,
      `${audioInputs}concat=n=${videoPaths.length}:v=0:a=1[a]`
    ];

    const outputPath = path.join(UPLOAD_DIR, `timeline-${Date.now()}.mp4`);

    // 4️⃣ Processa vídeo e envia para download
    command
      .complexFilter(filterComplex, ['v', 'a'])
      .outputOptions(['-map [v]', '-map [a]'])
      .on('start', cmdLine => console.log('Comando FFmpeg:', cmdLine))
      .on('error', (err, stdout, stderr) => {
        console.error('Erro FFmpeg:', err.message);
        console.error('FFmpeg stderr:', stderr);
        return res.status(500).json({ error: 'Erro ao processar vídeo', details: err.message });
      })
      .on('end', () => {
        console.log('Renderização concluída:', outputPath);
        // Envia arquivo diretamente para o cliente
        res.download(outputPath, 'timeline-output.mp4', (err) => {
          if (err) console.error('Erro ao enviar arquivo:', err);
          // Opcional: remover arquivo temporário após envio
          fs.unlinkSync(outputPath);
        });
      })
      .save(outputPath);

  } catch (err) {
    console.error('Erro no endpoint:', err);
    res.status(500).json({ error: 'Erro interno no servidor', details: err.message });
  }
});

app.listen(8080, () => {
  console.log('Servidor rodando na porta 8080');
});

